import { Model3D, Point3D } from '../../../types/mapping/sketch';

export interface OBJExportOptions {
  includeNormals?: boolean;
  includeTextures?: boolean;
  scale?: number;
  precision?: number;
}

export class OBJExporter {
  private options: Required<OBJExportOptions>;

  constructor(options: OBJExportOptions = {}) {
    this.options = {
      includeNormals: true,
      includeTextures: true,
      scale: 1.0,
      precision: 6,
      ...options
    };
  }

  /**
   * Export model to OBJ format string
   */
  exportToOBJ(model: Model3D): string {
    const lines: string[] = [];

    // Add header comment
    lines.push('# Generated by BuildingMapper');
    lines.push(`# Model: ${model.id}`);
    lines.push(`# Date: ${new Date(model.metadata.generatedAt).toISOString()}`);
    lines.push('');

    // Add material library reference if materials exist
    if (model.materials && Object.keys(model.materials).length > 0) {
      lines.push(`mtllib ${model.id}.mtl`);
      lines.push('');
    }

    // Add vertices
    model.vertices.forEach(vertex => {
      lines.push(this.formatVertex(vertex));
    });
    lines.push('');

    // Add texture coordinates if available
    if (this.options.includeTextures && model.textureCoords) {
      model.textureCoords.forEach(coord => {
        lines.push(this.formatTextureCoord(coord));
      });
      lines.push('');
    }

    // Add normals if available
    if (this.options.includeNormals && model.normals) {
      model.normals.forEach(normal => {
        lines.push(this.formatNormal(normal));
      });
      lines.push('');
    }

    // Add faces
    let currentMaterial: string | null = null;
    model.faces.forEach((face, index) => {
      // Check if face has material assignment
      const materialIndex = Math.floor(index / 3); // Assuming triangulated faces
      const materialKeys = model.materials ? Object.keys(model.materials) : [];
      const materialName = materialKeys[materialIndex % materialKeys.length];

      // Add material switch if needed
      if (materialName && materialName !== currentMaterial) {
        lines.push(`usemtl ${materialName}`);
        currentMaterial = materialName;
      }

      lines.push(this.formatFace(face, Boolean(model.textureCoords), Boolean(model.normals)));
    });

    return lines.join('\n');
  }

  /**
   * Export materials to MTL format string
   */
  exportToMTL(model: Model3D): string | null {
    if (!model.materials) return null;

    const lines: string[] = [];

    // Add header comment
    lines.push('# Generated by BuildingMapper');
    lines.push(`# Materials for model: ${model.id}`);
    lines.push(`# Date: ${new Date(model.metadata.generatedAt).toISOString()}`);
    lines.push('');

    // Add each material
    Object.entries(model.materials).forEach(([name, material]) => {
      lines.push(`newmtl ${name}`);

      if (material.color) {
        const [r, g, b] = material.color;
        lines.push(`Kd ${this.round(r)} ${this.round(g)} ${this.round(b)}`);
      }

      if (material.texture) {
        lines.push(`map_Kd ${material.texture}`);
      }

      if (material.opacity !== undefined) {
        lines.push(`d ${this.round(material.opacity)}`);
      }

      if (material.metallic !== undefined) {
        lines.push(`Pm ${this.round(material.metallic)}`);
      }

      if (material.roughness !== undefined) {
        lines.push(`Pr ${this.round(material.roughness)}`);
      }

      lines.push(''); // Add blank line between materials
    });

    return lines.join('\n');
  }

  /**
   * Format vertex as OBJ string
   */
  private formatVertex(vertex: Point3D): string {
    const x = this.round(vertex.x * this.options.scale);
    const y = this.round(vertex.y * this.options.scale);
    const z = this.round(vertex.z * this.options.scale);
    return `v ${x} ${y} ${z}`;
  }

  /**
   * Format texture coordinate as OBJ string
   */
  private formatTextureCoord(coord: { x: number; y: number }): string {
    const u = this.round(coord.x);
    const v = this.round(coord.y);
    return `vt ${u} ${v}`;
  }

  /**
   * Format normal as OBJ string
   */
  private formatNormal(normal: Point3D): string {
    const x = this.round(normal.x);
    const y = this.round(normal.y);
    const z = this.round(normal.z);
    return `vn ${x} ${y} ${z}`;
  }

  /**
   * Format face indices for OBJ format
   */
  private formatFaceIndex(
    vertexIndex: number,
    hasTextures: boolean,
    hasNormals: boolean
  ): string {
    // OBJ indices are 1-based
    const indices = [(vertexIndex + 1).toString()];
    
    if (hasTextures) {
      indices.push((vertexIndex + 1).toString());
    } else if (hasNormals) {
      indices.push(''); // Empty texture index
    }
    
    if (hasNormals) {
      indices.push((vertexIndex + 1).toString());
    }

    return indices.join('/');
  }

  /**
   * Format face as OBJ string
   */
  private formatFace(indices: number[], hasTextures: boolean, hasNormals: boolean): string {
    const faceIndices = indices.map(index => 
      this.formatFaceIndex(index, hasTextures, hasNormals)
    );

    return `f ${faceIndices.join(' ')}`;
  }

  /**
   * Round number to specified precision
   */
  private round(value: number): number {
    return Number(value.toFixed(this.options.precision));
  }

  /**
   * Update export options
   */
  setOptions(options: OBJExportOptions): void {
    this.options = {
      ...this.options,
      ...options
    };
  }

  /**
   * Get current options
   */
  getOptions(): OBJExportOptions {
    return { ...this.options };
  }
}
